<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>TINOC2_freeRTOS: Funciones &quot;Hook&quot; del FreeRTOS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="FLMW837IRLQLKCF.MEDIUM.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TINOC2_freeRTOS
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Firmware - Aplicacion de TINOC2 basada en freeRTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Funciones "Hook" del FreeRTOS</div>  </div>
</div><!--header-->
<div class="contents">

<p>Funciones handler de eventos de excepcion.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab7e5c95cf72a3f819bc4462a7fb62ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#gab7e5c95cf72a3f819bc4462a7fb62ca3">vApplicationMallocFailedHook</a> (void)</td></tr>
<tr class="memdesc:gab7e5c95cf72a3f819bc4462a7fb62ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#gab7e5c95cf72a3f819bc4462a7fb62ca3" title="vApplicationMallocFailedHook() will only be called if ">vApplicationMallocFailedHook()</a> will only be called if  <a href="#gab7e5c95cf72a3f819bc4462a7fb62ca3">More...</a><br /></td></tr>
<tr class="separator:gab7e5c95cf72a3f819bc4462a7fb62ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97fd430f36f8b065226e2bff9bad1de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga97fd430f36f8b065226e2bff9bad1de5">vApplicationIdleHook</a> (void)</td></tr>
<tr class="memdesc:ga97fd430f36f8b065226e2bff9bad1de5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga97fd430f36f8b065226e2bff9bad1de5" title="vApplicationIdleHook() will only be called if configUSE_IDLE_HOOK is set ">vApplicationIdleHook()</a> will only be called if configUSE_IDLE_HOOK is set  <a href="#ga97fd430f36f8b065226e2bff9bad1de5">More...</a><br /></td></tr>
<tr class="separator:ga97fd430f36f8b065226e2bff9bad1de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306672a74bdd13ce210c05fca3385c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga306672a74bdd13ce210c05fca3385c59">vApplicationStackOverflowHook</a> (<a class="el" href="task_8h.html#ae95f44d4cfeb4a599c6cc258d241cb6b">TaskHandle_t</a> pxTask, char *pcTaskName)</td></tr>
<tr class="memdesc:ga306672a74bdd13ce210c05fca3385c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run time stack overflow checking is performed if.  <a href="#ga306672a74bdd13ce210c05fca3385c59">More...</a><br /></td></tr>
<tr class="separator:ga306672a74bdd13ce210c05fca3385c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca051aa77e17583aa5a85d5de5c199a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga9ca051aa77e17583aa5a85d5de5c199a">vApplicationTickHook</a> (void)</td></tr>
<tr class="memdesc:ga9ca051aa77e17583aa5a85d5de5c199a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called by each tick interrupt if configUSE_TICK_HOOK is set to 1 in <a class="el" href="_free_r_t_o_s_config_8h.html">FreeRTOSConfig.h</a>. User code can be added here, but the tick hook is called from an interrupt context, so code must not attempt to block, and only the interrupt safe FreeRTOS API functions can be used (those that end in FromISR()). Manually check the last few bytes of the interrupt stack to check they have not been overwritten. Note - the task stacks are automatically checked for overflow if configCHECK_FOR_STACK_OVERFLOW is set to 1 or 2 in FreeRTOSConifg.h, but the interrupt stack is not.  <a href="#ga9ca051aa77e17583aa5a85d5de5c199a">More...</a><br /></td></tr>
<tr class="separator:ga9ca051aa77e17583aa5a85d5de5c199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Funciones handler de eventos de excepcion. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga97fd430f36f8b065226e2bff9bad1de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vApplicationIdleHook </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga97fd430f36f8b065226e2bff9bad1de5" title="vApplicationIdleHook() will only be called if configUSE_IDLE_HOOK is set ">vApplicationIdleHook()</a> will only be called if configUSE_IDLE_HOOK is set </p>
<p>void <a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga97fd430f36f8b065226e2bff9bad1de5" title="vApplicationIdleHook() will only be called if configUSE_IDLE_HOOK is set ">vApplicationIdleHook( void )</a> to 1 in <a class="el" href="_free_r_t_o_s_config_8h.html">FreeRTOSConfig.h</a>. It will be called on each iteration of the idle task. It is essential that code added to this hook function never attempts to block in any way (for example, call <a class="el" href="queue_8h.html#af1549eac0e7f05694a59a0b967c80be3">xQueueReceive()</a> with a block time specified, or call <a class="el" href="task_8h.html#aa154068cecd7f31446a7a84af44ab1a3">vTaskDelay()</a>). If the application makes use of the <a class="el" href="task_8h.html#a27ff4ebce26565bef136bda84201ff80">vTaskDelete()</a> API function (as this demo application does) then it is also important that <a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga97fd430f36f8b065226e2bff9bad1de5" title="vApplicationIdleHook() will only be called if configUSE_IDLE_HOOK is set ">vApplicationIdleHook()</a> is permitted to return to its calling function, because it is the responsibility of the idle task to clean up memory allocated by the kernel to any task that has since been deleted. </p><dl class="section author"><dt>Author</dt><dd>NXP </dd></dl>

<p>Definition at line <a class="el" href="main_8c_source.html#l00306">306</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab7e5c95cf72a3f819bc4462a7fb62ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vApplicationMallocFailedHook </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#gab7e5c95cf72a3f819bc4462a7fb62ca3" title="vApplicationMallocFailedHook() will only be called if ">vApplicationMallocFailedHook()</a> will only be called if </p>
<p>void <a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#gab7e5c95cf72a3f819bc4462a7fb62ca3" title="vApplicationMallocFailedHook() will only be called if ">vApplicationMallocFailedHook( void )</a> configUSE_MALLOC_FAILED_HOOK is set to 1 in <a class="el" href="_free_r_t_o_s_config_8h.html">FreeRTOSConfig.h</a>. It is a hook function that will get called if a call to <a class="el" href="portable_8h.html#a237d63f90b28e0950bd86f76815cd6e3">pvPortMalloc()</a> fails. <a class="el" href="portable_8h.html#a237d63f90b28e0950bd86f76815cd6e3">pvPortMalloc()</a> is called internally by the kernel whenever a task, queue, timer or semaphore is created. It is also called by various parts of the demo application. If <a class="el" href="heap__1_8c.html">heap_1.c</a> or heap_2.c are used, then the size of the heap available to <a class="el" href="portable_8h.html#a237d63f90b28e0950bd86f76815cd6e3">pvPortMalloc()</a> is defined by configTOTAL_HEAP_SIZE in <a class="el" href="_free_r_t_o_s_config_8h.html">FreeRTOSConfig.h</a>, and the <a class="el" href="portable_8h.html#a8f72fbee5c25c956bda528299ce6dd02">xPortGetFreeHeapSize()</a> API function can be used to query the size of free heap space that remains (although it does not provide information on how the remaining heap might be fragmented). memory, etc. are configured before <a class="el" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="Programa ppal. ">main()</a> is called. </p><dl class="section author"><dt>Author</dt><dd>NXP </dd></dl>

<p>Definition at line <a class="el" href="main_8c_source.html#l00284">284</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga306672a74bdd13ce210c05fca3385c59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vApplicationStackOverflowHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="task_8h.html#ae95f44d4cfeb4a599c6cc258d241cb6b">TaskHandle_t</a>&#160;</td>
          <td class="paramname"><em>pxTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcTaskName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run time stack overflow checking is performed if. </p>
<p>void <a class="el" href="group___h_o_o_k_f_u_n_c_t_i_o_n_s.html#ga306672a74bdd13ce210c05fca3385c59" title="Run time stack overflow checking is performed if. ">vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )</a> configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2. This hook function is called if a stack overflow is detected. </p><dl class="section author"><dt>Author</dt><dd>NXP </dd></dl>

<p>Definition at line <a class="el" href="main_8c_source.html#l00321">321</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ca051aa77e17583aa5a85d5de5c199a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vApplicationTickHook </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called by each tick interrupt if configUSE_TICK_HOOK is set to 1 in <a class="el" href="_free_r_t_o_s_config_8h.html">FreeRTOSConfig.h</a>. User code can be added here, but the tick hook is called from an interrupt context, so code must not attempt to block, and only the interrupt safe FreeRTOS API functions can be used (those that end in FromISR()). Manually check the last few bytes of the interrupt stack to check they have not been overwritten. Note - the task stacks are automatically checked for overflow if configCHECK_FOR_STACK_OVERFLOW is set to 1 or 2 in FreeRTOSConifg.h, but the interrupt stack is not. </p>
<p>vApplicationTickHook</p>
<dl class="section author"><dt>Author</dt><dd>NXP </dd></dl>

<p>Definition at line <a class="el" href="main_8c_source.html#l00351">351</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
